local Players           = game:GetService("Players")
local Workspace         = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService        = game:GetService("RunService")
local LocalPlayer       = Players.LocalPlayer

local GetPlayerDataRemote = nil
local RolesCache          = {}
local CurrentMapName      = nil
local MatchActive         = false
local LastSuccessfulPull  = 0
local IsPulling           = false

local EnableCount = 0
local Enabled     = false

local function FindGetPlayerData()
    if GetPlayerDataRemote and GetPlayerDataRemote.Parent then
        return GetPlayerDataRemote
    end
    GetPlayerDataRemote = ReplicatedStorage:FindFirstChild("GetPlayerData", true)
    if GetPlayerDataRemote and GetPlayerDataRemote:IsA("RemoteFunction") then
        return GetPlayerDataRemote
    end
    return nil
end

local function UpdateMapName()
    for _, obj in Workspace:GetChildren() do
        if (obj:IsA("Model") or obj:IsA("Folder")) and obj:GetAttribute("MapID") then
            CurrentMapName = obj.Name
            return true
        end
    end
    CurrentMapName = nil
    return false
end

local function PullPlayerData()
    if not Enabled or not CurrentMapName then
        return RolesCache
    end

    if IsPulling then return RolesCache end
    IsPulling = true

    local remote = FindGetPlayerData()
    if not remote then 
        IsPulling = false
        return RolesCache 
    end

    local success, data = pcall(remote.InvokeServer, remote)
    if success and typeof(data) == "table" then
        if next(data) then
            RolesCache = data
            MatchActive = true
            LastSuccessfulPull = tick()
        else
            RolesCache = {}
            MatchActive = false
        end
    end

    IsPulling = false
    return RolesCache
end

local AutoUpdater
local function StartAutoUpdate()
    if AutoUpdater then return end

    AutoUpdater = RunService.Heartbeat:Connect(function()
        if not Enabled then return end
        if not CurrentMapName then return end

        if not MatchActive then
            if tick() - LastSuccessfulPull > 2 then
                PullPlayerData()
                UpdateMapName()
            end
            return
        end

        if tick() - LastSuccessfulPull >= 0.5 then
            PullPlayerData()
        end
    end)
end

Workspace.ChildAdded:Connect(function(c)
    if c:GetAttribute("MapID") then
        UpdateMapName()
        if Enabled then
            PullPlayerData()
        end
    end
end)

Workspace.ChildRemoved:Connect(function(c)
    if c:GetAttribute("MapID") then
        MatchActive = false
        RolesCache = {}
        CurrentMapName = nil
    end
end)

task.spawn(function()
    task.wait(2)
    UpdateMapName()
    StartAutoUpdate()
end)

local function UpdateEnabledState()
    Enabled = (EnableCount > 0)

    if Enabled then
        UpdateMapName()
        PullPlayerData()
    else
        MatchActive = false
        RolesCache = {}
    end
end

local Match = {}

function Match.Enable()
    EnableCount += 1
    UpdateEnabledState()
end

function Match.Disable()
    EnableCount = math.max(EnableCount - 1, 0)
    UpdateEnabledState()
end

function Match.GetPD()           return PullPlayerData() end
function Match.Roles()           return RolesCache end
function Match.MyRole()          return RolesCache[LocalPlayer.Name] and RolesCache[LocalPlayer.Name].Role end
function Match.AmISheriffOrHero()
    local r = Match.MyRole()
    return r == "Sheriff" or r == "Hero"
end
function Match.IsAlive()         local i = RolesCache[LocalPlayer.Name] return i and not i.Dead end
function Match.MatchActive()     return MatchActive and next(RolesCache) end
function Match.HasMap()          return CurrentMapName ~= nil end
function Match.MapName()         return CurrentMapName end
function Match.GetRole(p)        p = p or LocalPlayer.Name return RolesCache[p] and RolesCache[p].Role end
function Match.IsPlayerDead(p)   p = p or LocalPlayer.Name return RolesCache[p] and RolesCache[p].Dead end
function Match.FindMurderer()
    for name, data in pairs(RolesCache) do
        if data.Role == "Murderer" and not data.Dead then
            return Players:FindFirstChild(name)
        end
    end
end

local CurrentCoins = 0
local MaxCoinsThisRound = 40
local HitMaxCoins = false

local CoinCollectedRemote = ReplicatedStorage.Remotes.Gameplay:WaitForChild("CoinCollected")
local CoinsStartedRemote   = ReplicatedStorage.Remotes.Gameplay:WaitForChild("CoinsStarted")

CoinsStartedRemote.OnClientEvent:Connect(function(data)
    local coinInfo = data and data.Coin
    if coinInfo then
        CurrentCoins = coinInfo.CollectedAmount or 0
        MaxCoinsThisRound = coinInfo.CollectionLimit or 40
        HitMaxCoins = (CurrentCoins >= MaxCoinsThisRound)
    else
        CurrentCoins = 0
        MaxCoinsThisRound = 40
        HitMaxCoins = false
    end
end)

CoinCollectedRemote.OnClientEvent:Connect(function(_, currentCoins, maxCoins, _)
    CurrentCoins = currentCoins or CurrentCoins
    MaxCoinsThisRound = maxCoins or MaxCoinsThisRound
    HitMaxCoins = (CurrentCoins >= MaxCoinsThisRound)
end)

RunService.Heartbeat:Connect(function()
    if not (Match.MatchActive() and Match.HasMap() and Match.IsAlive()) then
        CurrentCoins = 0
        MaxCoinsThisRound = 40
        HitMaxCoins = false
    end
end)

function Match.HasMaxCoins(p)
    p = p or LocalPlayer.Name
    local data = RolesCache[p]
    if not data then return false end
    return data.Coins and data.Coins >= MaxCoinsThisRound
end

return Match
